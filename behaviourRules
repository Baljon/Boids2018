    # funkcja ograniczająca wartości danego wektora (żeby nie były kosmiczne)
    def vectorLim(self, vector, lim):
        magnitude = sqrt(vector[0]**2 + vector[1]**2)
        if magnitude > lim:
            vector[0], vector[1] = vector[0] * lim / magnitude, vector[1] * lim / magnitude

    # funkcja ograniczająca wartości wektorów w tablicy X (korzysta z funkcji vectorLim)
    def matrixLim(self, matrix, lim):
        for vector in matrix:
            self.vectorLim(vector, lim)
    
    
    def behaviourRules(self):
        # ZASADA 1 - SEPARATION (minimal distance)
        distances = distMatrix < 15.0  # boolean matrix -> True, jeśli sąsiad jest za blisko
        vel = (vel * distances[:, :, None]).sum(axis=1) / distances.sum(axis=1).reshape(N, 1) * (-1)
        matrixLim(vel, maxStepVelocity)

        # ZASADA 2 - ALIGNMENT
        distances = distMatrix < 30.0 # szukamy lokalnej grupy

        vel2 = (vel * distances[:, :, None]).sum(axis=1) / distances.sum(axis=1).reshape(N, 1)
        matrixLim(vel, maxStepVelocity)
        vel += vel2

        # ZASADA 3 - COHESION
        vel3 = (pos * distances[:, :, None]).sum(axis=1) / distances.sum(axis=1).reshape(N, 1) - pos
        matrixLim(vel3, maxStepVelocity)
        vel += vel3

        return vel
